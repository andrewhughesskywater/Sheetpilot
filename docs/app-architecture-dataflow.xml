<?xml version="1.0" encoding="UTF-8"?>
<dataflow-architecture>
  <metadata>
    <name>SheetPilot Data Flow Architecture</name>
    <description>Documents all major data flow patterns through the SheetPilot application</description>
    <architecture>Event-driven architecture with IPC communication between Electron main and renderer processes</architecture>
  </metadata>

  <!-- ==================== AUTHENTICATION FLOWS ==================== -->
  <flow-category name="authentication" description="User authentication and session management flows">
    <summary>Three main flows: login (creates session), restoration (validates stored token), logout (clears session). All use SessionContext and database sessions table. Admin login bypasses credential storage. Sessions persist via localStorage.</summary>
    <keywords>authentication, login, logout, session, token, credentials, SessionContext, LoginDialog, admin, SWFL_ADMIN</keywords>
    
    <flow name="user-login">
      <description>User logs in and creates a new session</description>
      <trigger>User submits login form in LoginDialog</trigger>
      <keywords>login, authentication, session creation, credentials, admin login, stayLoggedIn, password hash</keywords>
      <related-files>
        <file>frontend/components/LoginDialog.tsx</file>
        <file>frontend/contexts/SessionContext.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/database.ts</file>
        <file>backend/src/preload.ts</file>
      </related-files>
      <related-flows>
        <flow>session-restoration</flow>
        <flow>user-logout</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/LoginDialog.tsx">
          <action>User enters email, password, and "stay logged in" preference</action>
          <data>{ email: string, password: string, stayLoggedIn: boolean }</data>
        </step>
        <step order="2" component="frontend/components/LoginDialog.tsx">
          <action>Component calls window.auth.login() via IPC bridge</action>
          <data>Sends { email, password, stayLoggedIn } to backend</data>
        </step>
        <step order="3" component="backend/src/preload.ts">
          <action>Preload bridge forwards IPC call to main process</action>
          <ipc-channel>auth:login</ipc-channel>
        </step>
        <step order="4" component="backend/src/main.ts">
          <action>IPC handler receives login request and validates credentials</action>
          <logic>
            - Check if Admin credentials (Admin/SWFL_ADMIN)
            - If admin: set isAdmin=true, skip credential storage
            - If regular user: store credentials in database via storeCredentials()
          </logic>
        </step>
        <step order="5" component="backend/src/services/database.ts">
          <action>Store user credentials in credentials table (if not admin)</action>
          <sql>INSERT INTO credentials (service, email, password_hash) VALUES ('smartsheet', ?, ?)</sql>
        </step>
        <step order="6" component="backend/src/services/database.ts">
          <action>Create session token and store in sessions table</action>
          <logic>
            - Generate random session token (crypto.randomBytes)
            - Calculate expiry based on stayLoggedIn flag
            - Store session in database
          </logic>
          <sql>INSERT INTO sessions (token, email, is_admin, expires_at) VALUES (?, ?, ?, ?)</sql>
        </step>
        <step order="7" component="backend/src/main.ts">
          <action>Return session token and isAdmin flag to renderer</action>
          <data>{ success: true, token: string, isAdmin: boolean }</data>
        </step>
        <step order="8" component="frontend/components/LoginDialog.tsx">
          <action>Receive login response and call onLoginSuccess callback</action>
        </step>
        <step order="9" component="frontend/contexts/SessionContext.tsx">
          <action>SessionContext.login() stores session in state and localStorage</action>
          <state-update>
            - setToken(token)
            - setEmail(email)
            - setIsAdmin(isAdmin)
            - localStorage.setItem('sessionToken', token)
          </state-update>
        </step>
        <step order="10" component="frontend/src/App.tsx">
          <action>App detects isLoggedIn=true and renders main content</action>
        </step>
      </steps>
      <result>User is authenticated, session created, and main app UI is displayed</result>
    </flow>

    <flow name="session-restoration">
      <description>Restore user session from localStorage on app startup</description>
      <trigger>SessionProvider mounts and runs useEffect on app load</trigger>
      <keywords>session restoration, auto-login, localStorage, token validation, validateSession, app startup</keywords>
      <related-files>
        <file>frontend/contexts/SessionContext.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/database.ts</file>
      </related-files>
      <related-flows>
        <flow>user-login</flow>
        <flow>user-logout</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/contexts/SessionContext.tsx">
          <action>Read session token from localStorage</action>
          <data>token = localStorage.getItem('sessionToken')</data>
        </step>
        <step order="2" component="frontend/contexts/SessionContext.tsx">
          <action>Call window.auth.validateSession(token) via IPC</action>
          <ipc-channel>auth:validateSession</ipc-channel>
        </step>
        <step order="3" component="backend/src/main.ts">
          <action>IPC handler validates session token</action>
          <logic>
            - Query sessions table for token
            - Check if session exists and not expired
            - Return { valid: boolean, email?: string, isAdmin?: boolean }
          </logic>
        </step>
        <step order="4" component="frontend/contexts/SessionContext.tsx">
          <action>Update session state if valid, otherwise clear localStorage</action>
          <state-update>
            If valid:
              - setToken(token)
              - setEmail(result.email)
              - setIsAdmin(result.isAdmin)
            If invalid:
              - localStorage.removeItem('sessionToken')
              - User remains logged out
          </state-update>
        </step>
        <step order="5" component="frontend/contexts/SessionContext.tsx">
          <action>Set isLoading=false to render UI</action>
        </step>
      </steps>
      <result>User session is restored (if valid) or user sees login dialog</result>
    </flow>

    <flow name="user-logout">
      <description>User logs out and clears session</description>
      <trigger>User clicks logout button in navigation menu</trigger>
      <keywords>logout, session cleanup, clear session, localStorage removal, SheetPilotNavigation</keywords>
      <related-files>
        <file>frontend/components/SheetPilotNavigation.tsx</file>
        <file>frontend/contexts/SessionContext.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/database.ts</file>
      </related-files>
      <related-flows>
        <flow>user-login</flow>
        <flow>session-restoration</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/SheetPilotNavigation.tsx">
          <action>Call SessionContext.logout()</action>
        </step>
        <step order="2" component="frontend/contexts/SessionContext.tsx">
          <action>Call window.auth.logout(token) via IPC</action>
          <ipc-channel>auth:logout</ipc-channel>
        </step>
        <step order="3" component="backend/src/main.ts">
          <action>IPC handler clears session from database</action>
          <logic>
            - Validate session to get email
            - Delete all sessions for user email
          </logic>
          <sql>DELETE FROM sessions WHERE email = ?</sql>
        </step>
        <step order="4" component="frontend/contexts/SessionContext.tsx">
          <action>Clear session state and localStorage</action>
          <state-update>
            - setToken(null)
            - setEmail(null)
            - setIsAdmin(false)
            - localStorage.removeItem('sessionToken')
          </state-update>
        </step>
        <step order="5" component="frontend/src/App.tsx">
          <action>App detects isLoggedIn=false and shows LoginDialog</action>
        </step>
      </steps>
      <result>User is logged out and login dialog is displayed</result>
    </flow>
  </flow-category>

  <!-- ==================== TIMESHEET DATA FLOWS ==================== -->
  <flow-category name="timesheet-data" description="Timesheet data creation, editing, and persistence flows">
    <summary>Four main flows: load draft (loads pending entries), save draft (persists individual changes), batch save (saves all on tab exit), delete draft (removes entries). All use TimesheetGrid component and DataContext. Time stored as minutes in database, displayed as HH:MM in UI. localStorage backup provides resilience.</summary>
    <keywords>timesheet, draft entries, TimesheetGrid, DataContext, Handsontable, time normalization, debounced save, localStorage backup, pending status</keywords>
    
    <flow name="load-draft-timesheets">
      <description>Load draft (pending) timesheet entries from database when user opens Timesheet tab</description>
      <trigger>User navigates to Timesheet tab in App</trigger>
      <keywords>load draft, pending entries, tab activation, lazy loading, time conversion, localStorage backup</keywords>
      <related-files>
        <file>frontend/src/App.tsx</file>
        <file>frontend/contexts/DataContext.tsx</file>
        <file>frontend/components/timesheet/TimesheetGrid.tsx</file>
        <file>backend/src/main.ts</file>
      </related-files>
      <related-flows>
        <flow>save-draft-entry</flow>
        <flow>batch-save-on-tab-exit</flow>
        <flow>delete-draft-entry</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/src/App.tsx">
          <action>Detect activeTab change to 0 (Timesheet)</action>
          <logic>useEffect monitors activeTab and calls refreshTimesheetDraft() when tab becomes active</logic>
        </step>
        <step order="2" component="frontend/contexts/DataContext.tsx">
          <action>refreshTimesheetDraft() calls loadTimesheetDraftData()</action>
          <state-update>setIsTimesheetDraftLoading(true)</state-update>
        </step>
        <step order="3" component="frontend/contexts/DataContext.tsx">
          <action>Call window.timesheet.loadDraft() via IPC</action>
          <ipc-channel>timesheet:loadDraft</ipc-channel>
        </step>
        <step order="4" component="backend/src/main.ts">
          <action>IPC handler queries database for pending entries</action>
          <sql>SELECT * FROM timesheet WHERE status IS NULL ORDER BY date ASC, time_in ASC</sql>
        </step>
        <step order="5" component="backend/src/main.ts">
          <action>Convert database format (time in minutes) to grid format (HH:MM strings)</action>
          <data-transformation>
            Database: { time_in: 480, time_out: 1020 } (minutes since midnight)
            Grid: { timeIn: "08:00", timeOut: "17:00" }
          </data-transformation>
        </step>
        <step order="6" component="backend/src/main.ts">
          <action>Return entries to renderer</action>
          <data>{ success: true, entries: TimesheetRow[] }</data>
        </step>
        <step order="7" component="frontend/contexts/DataContext.tsx">
          <action>Store entries in state and add blank row for new entries</action>
          <state-update>
            - setTimesheetDraftData([...entries, {}])
            - setIsTimesheetDraftLoading(false)
            - Create localStorage backup: localStorage.setItem('sheetpilot_timesheet_backup', JSON.stringify({ data: entries, timestamp: Date.now() }))
          </state-update>
        </step>
        <step order="8" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>TimesheetGrid receives data from DataContext and renders Handsontable</action>
        </step>
      </steps>
      <result>Timesheet grid displays draft entries ready for editing</result>
      <error-handling>
        <scenario>Database load fails</scenario>
        <action>Attempt to restore from localStorage backup</action>
        <fallback>Display empty grid with error message</fallback>
      </error-handling>
    </flow>

    <flow name="save-draft-entry">
      <description>Save a single draft timesheet entry to database</description>
      <trigger>User edits a cell in TimesheetGrid and triggers afterChange event</trigger>
      <keywords>save draft, cell edit, Handsontable afterChange, debouncing, validation, time conversion, INSERT OR UPDATE</keywords>
      <related-files>
        <file>frontend/components/timesheet/TimesheetGrid.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/database.ts</file>
      </related-files>
      <related-flows>
        <flow>load-draft-timesheets</flow>
        <flow>batch-save-on-tab-exit</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Handsontable afterChange event fired with row changes</action>
          <data>changes = [[row, prop, oldValue, newValue]]</data>
        </step>
        <step order="2" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Validate changed row has required fields (date, project, taskDescription)</action>
          <validation>Skip save if required fields are empty</validation>
        </step>
        <step order="3" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Debounce save operation (prevent excessive database writes)</action>
          <logic>Use setTimeout to delay save by 500ms, canceling previous timeout</logic>
        </step>
        <step order="4" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Extract row data and call window.timesheet.saveDraft() via IPC</action>
          <ipc-channel>timesheet:saveDraft</ipc-channel>
          <data>{ id?: number, date: string, timeIn: string, timeOut: string, project: string, tool?: string, chargeCode?: string, taskDescription: string }</data>
        </step>
        <step order="5" component="backend/src/main.ts">
          <action>IPC handler validates input data</action>
          <validation>
            - Required fields present (date, project, taskDescription)
            - Time format valid (HH:mm)
            - Time increments are 15 minutes
            - timeOut > timeIn
          </validation>
        </step>
        <step order="6" component="backend/src/main.ts">
          <action>Convert time strings to minutes since midnight</action>
          <data-transformation>
            "08:00" → 480 minutes
            "17:00" → 1020 minutes
          </data-transformation>
        </step>
        <step order="7" component="backend/src/main.ts">
          <action>Save to database via UPDATE or INSERT</action>
          <logic>
            If row.id exists: UPDATE existing row
            If no row.id: INSERT new row with deduplication constraint
          </logic>
          <sql>
            UPDATE: UPDATE timesheet SET date=?, time_in=?, time_out=?, ... WHERE id=?
            INSERT: INSERT INTO timesheet (...) VALUES (...) ON CONFLICT(date, time_in, project, task_description) DO UPDATE SET ...
          </sql>
        </step>
        <step order="8" component="backend/src/main.ts">
          <action>Return success result</action>
          <data>{ success: true, changes: number }</data>
        </step>
        <step order="9" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Update grid state if needed (e.g., set id on new row)</action>
        </step>
      </steps>
      <result>Draft entry is persisted to database and available for submission</result>
    </flow>

    <flow name="batch-save-on-tab-exit">
      <description>Save all modified entries when user leaves Timesheet tab</description>
      <trigger>User navigates away from Timesheet tab</trigger>
      <keywords>batch save, tab exit, timesheetGridRef, batchSaveToDatabase, onTabChange, persistence</keywords>
      <related-files>
        <file>frontend/src/App.tsx</file>
        <file>frontend/components/timesheet/TimesheetGrid.tsx</file>
      </related-files>
      <related-flows>
        <flow>save-draft-entry</flow>
        <flow>load-draft-timesheets</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/src/App.tsx">
          <action>Detect tab change in onTabChange handler</action>
          <logic>If leaving Timesheet tab (activeTab === 0 && newTab !== 0)</logic>
        </step>
        <step order="2" component="frontend/src/App.tsx">
          <action>Call timesheetGridRef.current.batchSaveToDatabase()</action>
        </step>
        <step order="3" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Iterate through all rows in grid</action>
          <logic>For each row with changes, trigger save via window.timesheet.saveDraft()</logic>
        </step>
        <step order="4" component="frontend/src/App.tsx">
          <action>Wait for all saves to complete, then proceed with tab change</action>
        </step>
      </steps>
      <result>All draft changes are persisted before tab transition</result>
    </flow>

    <flow name="delete-draft-entry">
      <description>Delete a draft entry from database</description>
      <trigger>User right-clicks row and selects "Delete Row" from context menu</trigger>
      <keywords>delete draft, row deletion, context menu, right-click, DELETE query, pending only</keywords>
      <related-files>
        <file>frontend/components/timesheet/TimesheetGrid.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/database.ts</file>
      </related-files>
      <related-flows>
        <flow>load-draft-timesheets</flow>
        <flow>save-draft-entry</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Get row data including id</action>
        </step>
        <step order="2" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Call window.timesheet.deleteDraft(id) via IPC</action>
          <ipc-channel>timesheet:deleteDraft</ipc-channel>
        </step>
        <step order="3" component="backend/src/main.ts">
          <action>Delete row from database (only if status is NULL)</action>
          <sql>DELETE FROM timesheet WHERE id = ? AND status IS NULL</sql>
        </step>
        <step order="4" component="frontend/components/timesheet/TimesheetGrid.tsx">
          <action>Remove row from grid data</action>
        </step>
      </steps>
      <result>Entry is removed from database and grid</result>
    </flow>
  </flow-category>

  <!-- ==================== SUBMISSION FLOWS ==================== -->
  <flow-category name="timesheet-submission" description="Automated timesheet submission via browser automation">
    <summary>Main submission flow coordinates browser automation via Electron BrowserWindow. Entries grouped by quarter, marked as 'in_progress' during submission to prevent conflicts. Successful entries marked 'Complete' with timestamp, failed entries revert to pending. Global isSubmissionInProgress flag prevents concurrent submissions. ElectronBotService handles authentication and form filling.</summary>
    <keywords>submission, automation, Electron BrowserWindow, bot, webform, authentication flow, quarter routing, StatusButton, timesheet-importer, concurrency protection</keywords>
    
    <flow name="submit-timesheets">
      <description>Submit all pending timesheet entries to web form via browser automation</description>
      <trigger>User clicks Submit button in StatusButton component</trigger>
      <keywords>submit, browser automation, Electron BrowserWindow, bot orchestration, authentication flow, webform flow, quarter config, credentials, progress callback</keywords>
      <related-files>
        <file>frontend/components/StatusButton.tsx</file>
        <file>backend/src/main.ts</file>
        <file>backend/src/services/timesheet-importer.ts</file>
        <file>backend/src/services/plugins/electron-bot-service.ts</file>
        <file>backend/src/services/bot/src/bot_orchestation.ts</file>
        <file>backend/src/services/bot/src/authentication_flow.ts</file>
        <file>backend/src/services/bot/src/webform_flow.ts</file>
        <file>backend/src/services/bot/src/quarter_config.ts</file>
      </related-files>
      <related-flows>
        <flow>load-draft-timesheets</flow>
        <flow>plugin-resolution</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/StatusButton.tsx">
          <action>Get session token from SessionContext</action>
        </step>
        <step order="2" component="frontend/components/StatusButton.tsx">
          <action>Call window.timesheet.submit(token) via IPC</action>
          <ipc-channel>timesheet:submit</ipc-channel>
        </step>
        <step order="3" component="backend/src/main.ts">
          <action>IPC handler validates session and checks permissions</action>
          <validation>
            - Session token is valid
            - User is not admin (admins cannot submit)
            - Not already submitting (global isSubmissionInProgress flag)
          </validation>
        </step>
        <step order="4" component="backend/src/main.ts">
          <action>Set isSubmissionInProgress = true to prevent concurrent submissions</action>
        </step>
        <step order="5" component="backend/src/main.ts">
          <action>Retrieve credentials for 'smartsheet' service</action>
          <logic>getCredentials('smartsheet') → { email, password }</logic>
        </step>
        <step order="6" component="backend/src/main.ts">
          <action>Call submitTimesheets(email, password) from timesheet-importer</action>
        </step>
        <step order="7" component="backend/src/services/timesheet-importer.ts">
          <action>Fetch pending timesheet entries from database</action>
          <sql>SELECT * FROM timesheet WHERE status IS NULL</sql>
        </step>
        <step order="8" component="backend/src/services/timesheet-importer.ts">
          <action>Mark entries as 'in_progress' to protect from concurrent operations</action>
          <sql>UPDATE timesheet SET status = 'in_progress' WHERE id IN (...)</sql>
        </step>
        <step order="9" component="backend/src/services/timesheet-importer.ts">
          <action>Convert database entries to TimesheetEntry format</action>
          <data-transformation>
            Database format (time_in: 480) → API format (timeIn: "08:00")
            Date format MM/DD/YYYY → YYYY-MM-DD for quarter matching
          </data-transformation>
        </step>
        <step order="10" component="backend/src/services/timesheet-importer.ts">
          <action>Resolve submission service from plugin registry</action>
          <logic>getSubmissionService() → ElectronBotService (or MockSubmissionService)</logic>
        </step>
        <step order="11" component="backend/src/services/plugins/electron-bot-service.ts">
          <action>Plugin's submit() method called with entries and credentials</action>
        </step>
        <step order="12" component="backend/src/services/bot/src/bot_orchestation.ts">
          <action>Group entries by quarter based on date</action>
          <logic>Determine which quarter each entry belongs to using quarter_config</logic>
        </step>
        <step order="13" component="backend/src/services/bot/src/bot_orchestation.ts">
          <action>Launch Electron BrowserWindow instance</action>
          <config>Headless mode, bundled Chromium</config>
        </step>
        <step order="14" component="backend/src/services/bot/src/authentication_flow.ts">
          <action>Navigate to login page and authenticate</action>
          <actions>
            - Navigate to login URL
            - Fill email field
            - Fill password field
            - Click login button
            - Wait for navigation to dashboard
          </actions>
        </step>
        <step order="15" component="backend/src/services/bot/src/bot_orchestation.ts">
          <action>For each quarter with entries, submit entries to that quarter's form</action>
        </step>
        <step order="16" component="backend/src/services/bot/src/webform_flow.ts">
          <action>Navigate to quarter-specific form URL</action>
          <logic>Use quarter configuration to get correct SmartSheet form ID</logic>
        </step>
        <step order="17" component="backend/src/services/bot/src/webform_flow.ts">
          <action>For each entry, fill form fields and submit</action>
          <actions>
            - Fill date field
            - Fill time in field
            - Fill time out field
            - Select project from dropdown
            - Select tool from cascading dropdown (if applicable)
            - Select charge code from cascading dropdown (if applicable)
            - Fill task description
            - Click submit button
            - Wait for success confirmation
          </actions>
        </step>
        <step order="18" component="backend/src/services/bot/src/webform_flow.ts">
          <action>Track successful and failed submissions</action>
          <data>
            submittedIds: number[] - successfully submitted entry IDs
            removedIds: number[] - failed entry IDs to revert
          </data>
        </step>
        <step order="19" component="backend/src/services/bot/src/bot_orchestation.ts">
          <action>Close browser instance</action>
        </step>
        <step order="20" component="backend/src/services/bot/src/bot_orchestation.ts">
          <action>Return submission result</action>
          <data>{ ok: boolean, submittedIds: number[], removedIds: number[], totalProcessed: number, successCount: number, removedCount: number }</data>
        </step>
        <step order="21" component="backend/src/services/timesheet-importer.ts">
          <action>Update database based on results</action>
          <logic>
            - Mark submittedIds as 'Complete' with submitted_at timestamp
            - Revert removedIds back to NULL status (pending)
          </logic>
          <sql>
            Success: UPDATE timesheet SET status = 'Complete', submitted_at = datetime('now') WHERE id IN (...)
            Failed: UPDATE timesheet SET status = NULL WHERE id IN (...)
          </sql>
        </step>
        <step order="22" component="backend/src/main.ts">
          <action>Set isSubmissionInProgress = false</action>
        </step>
        <step order="23" component="backend/src/main.ts">
          <action>Return submission result to renderer</action>
          <data>{ submitResult: SubmissionResult, dbPath: string }</data>
        </step>
        <step order="24" component="frontend/components/StatusButton.tsx">
          <action>Display success or error message based on result</action>
          <ui>Show success count, error count, or error message</ui>
        </step>
        <step order="25" component="frontend/contexts/DataContext.tsx">
          <action>Refresh draft data to remove submitted entries from grid</action>
        </step>
      </steps>
      <result>Pending entries are submitted to web forms, database is updated with results, and UI reflects changes</result>
      <error-handling>
        <scenario>Authentication fails</scenario>
        <action>Abort submission, return error to user</action>
        <scenario>Form validation error</scenario>
        <action>Mark entry as failed, continue with remaining entries</action>
        <scenario>Network error</scenario>
        <action>Retry with exponential backoff, then mark as failed</action>
        <scenario>Concurrent submission attempt</scenario>
        <action>Reject with "submission already in progress" error</action>
      </error-handling>
    </flow>
  </flow-category>

  <!-- ==================== ARCHIVE DATA FLOWS ==================== -->
  <flow-category name="archive-data" description="Viewing completed timesheet entries and stored credentials">
    <summary>Two main flows: load archive (fetches completed entries and credentials), export CSV (converts to CSV format). Both require valid session token. Archive data loaded lazily when Archive tab activated. DatabaseViewer component displays historical data.</summary>
    <keywords>archive, completed entries, credentials viewer, DatabaseViewer, CSV export, historical data, tab activation</keywords>
    
    <flow name="load-archive-data">
      <description>Load completed timesheet entries and credentials when user opens Archive tab</description>
      <trigger>User navigates to Archive tab</trigger>
      <keywords>load archive, completed entries, credentials metadata, lazy loading, session validation, DatabaseViewer</keywords>
      <related-files>
        <file>frontend/src/App.tsx</file>
        <file>frontend/contexts/DataContext.tsx</file>
        <file>frontend/components/archive/DatabaseViewer.tsx</file>
        <file>backend/src/main.ts</file>
      </related-files>
      <related-flows>
        <flow>export-csv</flow>
        <flow>load-draft-timesheets</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/src/App.tsx">
          <action>Detect activeTab change to 1 (Archive)</action>
          <logic>useEffect monitors activeTab and calls refreshArchiveData() when tab becomes active</logic>
        </step>
        <step order="2" component="frontend/contexts/DataContext.tsx">
          <action>refreshArchiveData() calls loadArchiveData()</action>
          <state-update>setIsArchiveDataLoading(true)</state-update>
        </step>
        <step order="3" component="frontend/contexts/DataContext.tsx">
          <action>Call window.database.getAllArchiveData(token) via IPC (batched)</action>
          <ipc-channel>database:getAllArchiveData</ipc-channel>
        </step>
        <step order="4" component="backend/src/main.ts">
          <action>IPC handler validates session token</action>
          <validation>Token must be valid to access archive data</validation>
        </step>
        <step order="5" component="backend/src/main.ts">
          <action>Query database for completed entries and credentials</action>
          <sql>
            Timesheet: SELECT * FROM timesheet WHERE status = 'Complete' ORDER BY date DESC, time_in DESC
            Credentials: SELECT id, service, email, created_at, updated_at FROM credentials ORDER BY service
          </sql>
        </step>
        <step order="6" component="backend/src/main.ts">
          <action>Return batched result</action>
          <data>{ success: true, timesheet: DbTimesheetEntry[], credentials: Credential[] }</data>
        </step>
        <step order="7" component="frontend/contexts/DataContext.tsx">
          <action>Store archive data in state</action>
          <state-update>
            - setArchiveData({ timesheet, credentials })
            - setIsArchiveDataLoading(false)
          </state-update>
        </step>
        <step order="8" component="frontend/components/archive/DatabaseViewer.tsx">
          <action>Render archive tables with data from DataContext</action>
          <ui>
            - Timesheet table with all completed entries
            - Credentials table with stored services
          </ui>
        </step>
      </steps>
      <result>Archive tab displays historical data</result>
    </flow>

    <flow name="export-csv">
      <description>Export completed timesheet entries to CSV file</description>
      <trigger>User clicks Export CSV button in DatabaseViewer</trigger>
      <keywords>CSV export, download, data transformation, time conversion, browser download, Blob</keywords>
      <related-files>
        <file>frontend/components/archive/DatabaseViewer.tsx</file>
        <file>backend/src/main.ts</file>
      </related-files>
      <related-flows>
        <flow>load-archive-data</flow>
      </related-flows>
      <steps>
        <step order="1" component="frontend/components/archive/DatabaseViewer.tsx">
          <action>Call window.timesheet.exportToCSV() via IPC</action>
          <ipc-channel>timesheet:exportToCSV</ipc-channel>
        </step>
        <step order="2" component="backend/src/main.ts">
          <action>Query database for submitted entries</action>
          <sql>SELECT * FROM timesheet WHERE status = 'Complete'</sql>
        </step>
        <step order="3" component="backend/src/main.ts">
          <action>Convert to CSV format</action>
          <data-transformation>
            - Convert time_in/time_out from minutes to HH:MM
            - Escape special characters in text fields
            - Format columns: Date, Start Time, End Time, Hours, Project, Tool, Charge Code, Task Description, Status, Submitted At
          </data-transformation>
        </step>
        <step order="4" component="backend/src/main.ts">
          <action>Return CSV content and metadata</action>
          <data>{ success: true, csvData: string, entryCount: number, filename: string }</data>
        </step>
        <step order="5" component="frontend/components/archive/DatabaseViewer.tsx">
          <action>Trigger browser download with CSV content</action>
          <logic>
            - Create Blob with CSV data
            - Create download link
            - Trigger click
            - Clean up
          </logic>
        </step>
      </steps>
      <result>CSV file is downloaded to user's system</result>
    </flow>
  </flow-category>

  <!-- ==================== PLUGIN RESOLUTION FLOWS ==================== -->
  <flow-category name="plugin-resolution" description="How services are resolved via the plugin system">
    <summary>Three main flows: registration (startup initialization), resolution (runtime lookup), swap (configuration change). Plugin registry is a singleton. Namespaces: data, credentials, submission. Configuration driven by plugin-config.json. Enables swappable implementations without code changes.</summary>
    <keywords>plugin system, plugin registry, bootstrap-plugins, namespaces, configuration, swappable implementations, dependency injection, singleton</keywords>
    
    <flow name="plugin-registration">
      <description>Plugins are registered during application startup</description>
      <trigger>Application startup in main.ts</trigger>
      <keywords>plugin registration, app startup, registerDefaultPlugins, plugin-config.json, initialize lifecycle</keywords>
      <related-files>
        <file>backend/src/main.ts</file>
        <file>backend/src/middleware/bootstrap-plugins.ts</file>
        <file>shared/plugin-registry.ts</file>
        <file>shared/plugin-config.ts</file>
        <file>backend/src/services/plugins/sqlite-data-service.ts</file>
        <file>backend/src/services/plugins/sqlite-credential-service.ts</file>
        <file>backend/src/services/plugins/electron-bot-service.ts</file>
        <file>backend/src/services/plugins/mock-submission-service.ts</file>
      </related-files>
      <related-flows>
        <flow>plugin-resolution</flow>
        <flow>plugin-swap</flow>
      </related-flows>
      <steps>
        <step order="1" component="backend/src/main.ts">
          <action>Call registerDefaultPlugins() during app.whenReady()</action>
        </step>
        <step order="2" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Get singleton PluginRegistry instance</action>
        </step>
        <step order="3" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Load plugin configuration from plugin-config.json</action>
          <data>
            {
              "plugins": {
                "data": { "active": "sqlite" },
                "credentials": { "active": "sqlite" },
                "submission": { "active": "electron" }
              }
            }
          </data>
        </step>
        <step order="4" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Register data service plugins</action>
          <logic>
            registry.registerPlugin('data', 'sqlite', new SQLiteDataService())
            registry.registerPlugin('data', 'memory', new MemoryDataService())
          </logic>
        </step>
        <step order="5" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Register credential service plugins</action>
          <logic>
            registry.registerPlugin('credentials', 'sqlite', new SQLiteCredentialService())
          </logic>
        </step>
        <step order="6" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Register submission service plugins</action>
          <logic>
            registry.registerPlugin('submission', 'electron', new ElectronBotService())
            registry.registerPlugin('submission', 'mock', new MockSubmissionService())
          </logic>
        </step>
        <step order="7" component="shared/plugin-registry.ts">
          <action>Plugin registry calls initialize() on each registered plugin</action>
          <logic>If plugin implements IPlugin interface with initialize() method</logic>
        </step>
      </steps>
      <result>All plugins are registered and initialized, ready for resolution</result>
    </flow>

    <flow name="plugin-resolution">
      <description>Resolve active plugin for a namespace during runtime</description>
      <trigger>Service code needs to use a plugin (e.g., submission service)</trigger>
      <keywords>plugin resolution, getPlugin, active plugin, namespace lookup, runtime resolution, getSubmissionService</keywords>
      <related-files>
        <file>backend/src/services/timesheet-importer.ts</file>
        <file>backend/src/middleware/bootstrap-plugins.ts</file>
        <file>shared/plugin-registry.ts</file>
      </related-files>
      <related-flows>
        <flow>plugin-registration</flow>
        <flow>submit-timesheets</flow>
      </related-flows>
      <steps>
        <step order="1" component="backend/src/services/timesheet-importer.ts">
          <action>Call getSubmissionService() to resolve active submission plugin</action>
        </step>
        <step order="2" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Forward call to PluginRegistry.getPlugin('submission')</action>
        </step>
        <step order="3" component="shared/plugin-registry.ts">
          <action>Look up active plugin name for 'submission' namespace</action>
          <logic>activePlugins.get('submission') → 'electron'</logic>
        </step>
        <step order="4" component="shared/plugin-registry.ts">
          <action>Retrieve plugin implementation by namespace and name</action>
          <logic>plugins.get('submission').get('electron') → ElectronBotService instance</logic>
        </step>
        <step order="5" component="backend/src/services/timesheet-importer.ts">
          <action>Use returned plugin to perform operation</action>
          <logic>submissionService.submit(entries, credentials, progressCallback)</logic>
        </step>
      </steps>
      <result>Correct plugin implementation is used based on configuration</result>
    </flow>

    <flow name="plugin-swap">
      <description>Change active plugin for testing or configuration</description>
      <trigger>Developer or test code changes plugin-config.json</trigger>
      <keywords>plugin swap, configuration change, mock service, testing, active plugin change, app restart</keywords>
      <related-files>
        <file>plugin-config.json</file>
        <file>backend/src/middleware/bootstrap-plugins.ts</file>
      </related-files>
      <related-flows>
        <flow>plugin-registration</flow>
        <flow>plugin-resolution</flow>
      </related-flows>
      <steps>
        <step order="1" component="plugin-config.json">
          <action>Update active plugin in configuration file</action>
          <change>
            Before: "submission": { "active": "electron" }
            After: "submission": { "active": "mock" }
          </change>
        </step>
        <step order="2" component="Application">
          <action>Restart application to reload configuration</action>
        </step>
        <step order="3" component="backend/src/middleware/bootstrap-plugins.ts">
          <action>Load updated configuration and set active plugins</action>
        </step>
        <step order="4" component="backend/src/services/timesheet-importer.ts">
          <action>Subsequent calls to getSubmissionService() resolve to MockSubmissionService</action>
        </step>
      </steps>
      <result>Plugin behavior is swapped without code changes</result>
    </flow>
  </flow-category>

  <!-- ==================== IPC COMMUNICATION PATTERNS ==================== -->
  <flow-category name="ipc-communication" description="Inter-Process Communication patterns between renderer and main">
    <summary>Three main patterns: request-response (standard async operations), event-broadcast (server-push updates), logging-bridge (renderer logs forwarded to main). All communication goes through preload.ts contextBridge for security. Type-safe via TypeScript interfaces.</summary>
    <keywords>IPC, inter-process communication, Electron, preload, contextBridge, ipcRenderer, ipcMain, request-response, event-broadcast</keywords>
    
    <pattern name="request-response">
      <description>Standard request-response pattern for data operations</description>
      <example>Loading draft timesheet entries</example>
      <keywords>request-response, ipcRenderer.invoke, ipcMain.handle, async operations, Promise-based</keywords>
      <related-files>
        <file>backend/src/preload.ts</file>
        <file>backend/src/main.ts</file>
        <file>frontend/src/contracts/window.ts</file>
      </related-files>
      <flow>
        <step order="1" layer="renderer">
          <action>Component calls window.timesheet.loadDraft()</action>
        </step>
        <step order="2" layer="preload">
          <action>Preload bridge forwards to ipcRenderer.invoke('timesheet:loadDraft')</action>
        </step>
        <step order="3" layer="main">
          <action>IPC handler processes request, queries database, returns result</action>
        </step>
        <step order="4" layer="preload">
          <action>Promise resolves with result from main</action>
        </step>
        <step order="5" layer="renderer">
          <action>Component receives result and updates state</action>
        </step>
      </flow>
    </pattern>

    <pattern name="event-broadcast">
      <description>Main process broadcasts events to renderer (e.g., update events)</description>
      <example>Auto-update download progress</example>
      <keywords>event broadcast, webContents.send, ipcRenderer.on, server push, auto-update, progress events</keywords>
      <related-files>
        <file>backend/src/main.ts</file>
        <file>backend/src/preload.ts</file>
        <file>frontend/src/App.tsx</file>
      </related-files>
      <flow>
        <step order="1" layer="main">
          <action>Auto-updater emits 'download-progress' event</action>
        </step>
        <step order="2" layer="main">
          <action>Main process sends IPC event: mainWindow.webContents.send('download-progress', progress)</action>
        </step>
        <step order="3" layer="preload">
          <action>Preload exposes listener: window.updates.onDownloadProgress(callback)</action>
        </step>
        <step order="4" layer="renderer">
          <action>Component registers listener and receives progress updates</action>
        </step>
      </flow>
    </pattern>

    <pattern name="logging-bridge">
      <description>Renderer logs are forwarded to main process logger</description>
      <example>Component logs error</example>
      <keywords>logging bridge, window.logger, renderer logs, main process logger, structured logging, log forwarding</keywords>
      <related-files>
        <file>backend/src/preload.ts</file>
        <file>backend/src/main.ts</file>
        <file>shared/logger.ts</file>
        <file>frontend/src/utils/logger-fallback.ts</file>
      </related-files>
      <flow>
        <step order="1" layer="renderer">
          <action>Component calls window.logger.error('Message', { data })</action>
        </step>
        <step order="2" layer="preload">
          <action>Preload forwards to ipcRenderer.send('logger:error', message, data)</action>
        </step>
        <step order="3" layer="main">
          <action>IPC handler receives log and forwards to main process logger</action>
        </step>
        <step order="4" layer="main">
          <action>Logger writes to file with full context (session ID, timestamp, etc.)</action>
        </step>
      </flow>
    </pattern>
  </flow-category>

  <!-- ==================== DATA PERSISTENCE PATTERNS ==================== -->
  <flow-category name="data-persistence" description="How data is persisted across different storage layers">
    <summary>Four main patterns: database (SQLite primary storage), localStorage backup (resilience), session persistence (auto-login), macro persistence (templates). Database at userData/sheetpilot.sqlite. localStorage provides fallback for draft data and session tokens.</summary>
    <keywords>persistence, SQLite, database, localStorage, sessions, macros, backup, resilience, userData</keywords>
    
    <pattern name="database-persistence">
      <description>Primary data storage in SQLite database</description>
      <storage>SQLite database file at userData/sheetpilot.sqlite</storage>
      <keywords>SQLite, database, better-sqlite3, timesheet table, credentials table, sessions table, schema</keywords>
      <related-files>
        <file>backend/src/services/database.ts</file>
        <file>backend/src/repositories/timesheet-repository.ts</file>
        <file>backend/src/repositories/credentials-repository.ts</file>
        <file>backend/src/repositories/session-repository.ts</file>
      </related-files>
      <tables>
        <table name="timesheet">
          <purpose>Store timesheet entries (draft, in-progress, completed)</purpose>
          <key-columns>id, date, time_in, time_out, project, tool, detail_charge_code, task_description, status, submitted_at</key-columns>
        </table>
        <table name="credentials">
          <purpose>Store service credentials (encrypted passwords)</purpose>
          <key-columns>id, service, email, password_hash, created_at, updated_at</key-columns>
        </table>
        <table name="sessions">
          <purpose>Store user session tokens</purpose>
          <key-columns>id, token, email, is_admin, created_at, expires_at</key-columns>
        </table>
      </tables>
    </pattern>

    <pattern name="localstorage-backup">
      <description>Backup draft data to localStorage for resilience</description>
      <purpose>Protect against database connection failures or corruption</purpose>
      <keywords>localStorage, backup, resilience, sheetpilot_timesheet_backup, data recovery, fallback</keywords>
      <related-files>
        <file>frontend/contexts/DataContext.tsx</file>
      </related-files>
      <flow>
        <step>After successful database load, DataContext saves to localStorage</step>
        <step>If database load fails, DataContext attempts to restore from localStorage</step>
        <step>User sees warning that data was restored from backup</step>
      </flow>
      <data-format>
        {
          "data": TimesheetRow[],
          "timestamp": number
        }
      </data-format>
    </pattern>

    <pattern name="session-persistence">
      <description>Session token persisted to localStorage for auto-login</description>
      <purpose>Keep user logged in across app restarts</purpose>
      <keywords>session persistence, auto-login, sessionToken, localStorage, token validation</keywords>
      <related-files>
        <file>frontend/contexts/SessionContext.tsx</file>
      </related-files>
      <flow>
        <step>On login, SessionContext saves token to localStorage</step>
        <step>On app startup, SessionContext reads token from localStorage</step>
        <step>Token is validated with backend</step>
        <step>If valid, session is restored; if invalid, token is cleared</step>
      </flow>
    </pattern>

    <pattern name="macro-persistence">
      <description>Saved macros (quick-fill templates) stored in localStorage</description>
      <purpose>Allow users to save frequently-used timesheet patterns</purpose>
      <storage>localStorage key: 'sheetpilot_macros'</storage>
      <keywords>macros, quick-fill, templates, localStorage, macroStorage, saved patterns</keywords>
      <related-files>
        <file>frontend/src/utils/macroStorage.ts</file>
        <file>frontend/components/timesheet/MacroManagerDialog.tsx</file>
      </related-files>
      <data-format>
        {
          "macroName": {
            project: string,
            tool?: string,
            chargeCode?: string,
            taskDescription: string
          }
        }
      </data-format>
    </pattern>
  </flow-category>

  <!-- ==================== STATE MANAGEMENT PATTERNS ==================== -->
  <flow-category name="state-management" description="How application state is managed in the frontend">
    <summary>Three main patterns: context-based state (React Context API), lazy loading (data loads on-demand), optimistic updates (UI updates immediately). SessionContext manages auth, DataContext manages timesheet/archive data. No external state management libraries used.</summary>
    <keywords>state management, React Context, SessionContext, DataContext, lazy loading, optimistic updates, useState, useEffect</keywords>
    
    <pattern name="context-based-state">
      <description>Global state managed via React Context API</description>
      <keywords>React Context, SessionContext, DataContext, global state, provider pattern, useContext hook</keywords>
      <related-files>
        <file>frontend/contexts/SessionContext.tsx</file>
        <file>frontend/contexts/DataContext.tsx</file>
        <file>frontend/src/App.tsx</file>
      </related-files>
      <contexts>
        <context name="SessionContext">
          <state>isLoggedIn, token, email, isAdmin, isLoading</state>
          <persistence>localStorage (token only)</persistence>
          <scope>Authentication state</scope>
        </context>
        <context name="DataContext">
          <state>timesheetDraftData, archiveData, loading states, error states</state>
          <persistence>localStorage backup for draft data</persistence>
          <scope>Timesheet and archive data</scope>
        </context>
      </contexts>
    </pattern>

    <pattern name="lazy-loading">
      <description>Data is loaded only when needed (tab activation)</description>
      <purpose>Improve startup performance by deferring data loads</purpose>
      <keywords>lazy loading, tab activation, on-demand loading, performance optimization, deferred loading</keywords>
      <related-files>
        <file>frontend/src/App.tsx</file>
        <file>frontend/contexts/DataContext.tsx</file>
      </related-files>
      <implementation>
        <step>DataContext does NOT load data on mount</step>
        <step>App component watches activeTab changes</step>
        <step>When tab becomes active, App calls appropriate refresh function</step>
        <step>DataContext loads data and updates state</step>
      </implementation>
    </pattern>

    <pattern name="optimistic-updates">
      <description>UI updates immediately, then syncs with backend</description>
      <example>Editing timesheet cell</example>
      <keywords>optimistic updates, UI responsiveness, Handsontable, immediate feedback, background sync, debouncing</keywords>
      <related-files>
        <file>frontend/components/timesheet/TimesheetGrid.tsx</file>
      </related-files>
      <implementation>
        <step>User edits cell, Handsontable updates grid immediately</step>
        <step>afterChange event triggers debounced save to database</step>
        <step>If save fails, error is logged but grid remains updated</step>
      </implementation>
    </pattern>
  </flow-category>

  <!-- ==================== ERROR HANDLING PATTERNS ==================== -->
  <flow-category name="error-handling" description="How errors are handled throughout the application">
    <summary>Three main patterns: structured errors (custom classes with context), fallback mechanisms (graceful degradation), error recovery (automatic retry). All errors logged with structured context. User-friendly messages generated from error codes.</summary>
    <keywords>error handling, structured errors, AppError, fallback mechanisms, error recovery, retry logic, graceful degradation</keywords>
    
    <pattern name="structured-errors">
      <description>Custom error classes with codes and context</description>
      <keywords>custom errors, error classes, AppError, DatabaseConnectionError, CredentialsNotFoundError, error codes, context</keywords>
      <related-files>
        <file>shared/errors.ts</file>
      </related-files>
      <error-classes>
        <class name="DatabaseConnectionError">Database connection failures</class>
        <class name="DatabaseSchemaError">Schema initialization errors</class>
        <class name="CredentialsNotFoundError">Missing credentials</class>
        <class name="CredentialsStorageError">Credential storage failures</class>
      </error-classes>
      <flow>
        <step>Service code throws custom error with context</step>
        <step>Error is caught in IPC handler or higher level</step>
        <step>Error is logged with full context</step>
        <step>User-friendly message is generated</step>
        <step>UI displays error to user</step>
      </flow>
    </pattern>

    <pattern name="fallback-mechanisms">
      <description>Graceful degradation when services fail</description>
      <keywords>fallback, graceful degradation, localStorage restore, logger fallback, API fallback, resilience</keywords>
      <related-files>
        <file>frontend/contexts/DataContext.tsx</file>
        <file>frontend/src/utils/logger-fallback.ts</file>
        <file>frontend/src/utils/api-fallback.ts</file>
      </related-files>
      <examples>
        <example>
          <scenario>Database load fails</scenario>
          <fallback>Restore from localStorage backup</fallback>
        </example>
        <example>
          <scenario>window.logger is undefined (development mode)</scenario>
          <fallback>Use console-based logger from logger-fallback</fallback>
        </example>
        <example>
          <scenario>IPC API is undefined (development mode)</scenario>
          <fallback>Use mock API from api-fallback</fallback>
        </example>
      </examples>
    </pattern>

    <pattern name="error-recovery">
      <description>Automatic retry and recovery mechanisms</description>
      <keywords>error recovery, retry logic, exponential backoff, form submission retry, network timeout, failed entry recovery</keywords>
      <related-files>
        <file>backend/src/services/bot/src/webform_flow.ts</file>
        <file>backend/src/services/bot/src/authentication_flow.ts</file>
        <file>backend/src/services/timesheet-importer.ts</file>
      </related-files>
      <examples>
        <example>
          <scenario>Form submission fails</scenario>
          <action>Bot retries with exponential backoff</action>
        </example>
        <example>
          <scenario>Network timeout during authentication</scenario>
          <action>Bot retries authentication up to 3 times</action>
        </example>
        <example>
          <scenario>Entry submission fails</scenario>
          <action>Mark entry as failed, revert to pending, continue with remaining entries</action>
        </example>
      </examples>
    </pattern>
  </flow-category>
</dataflow-architecture>

